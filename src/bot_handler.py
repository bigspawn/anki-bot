"""
Refactored Telegram bot handler using modular architecture
"""

import contextlib
import logging
from functools import wraps

from telegram import ReplyKeyboardRemove, Update
from telegram.error import TelegramError
from telegram.ext import (
    Application,
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters,
)

from .config import get_settings
from .core.database.database_manager import get_db_manager
from .core.handlers.command_handlers import CommandHandlers
from .core.handlers.message_handlers import MessageHandlers
from .core.locks.user_lock_manager import UserLockManager
from .core.session.session_manager import SessionManager
from .core.state.user_state_manager import UserStateManager
from .spaced_repetition import get_srs_system
from .text_parser import get_text_parser
from .utils import Timer
from .word_processor import get_word_processor

logger = logging.getLogger(__name__)


class BotHandler:
    """Main Telegram bot handler using modular architecture"""

    def __init__(self, settings=None):
        self.settings = settings or get_settings()
        self.db_manager = get_db_manager()
        self.word_processor = get_word_processor()
        self.text_parser = get_text_parser()
        self.srs_system = get_srs_system()
        self.lock_manager = UserLockManager(lock_timeout_minutes=5)
        self.state_manager = UserStateManager(state_timeout_minutes=10)

        self.application = None

        # Initialize modular components
        self.session_manager = SessionManager(
            db_manager=self.db_manager,
            srs_system=self.srs_system,
            safe_reply_callback=self._safe_reply,
            safe_edit_callback=self._safe_edit,
        )

        self.command_handlers = CommandHandlers(
            db_manager=self.db_manager,
            word_processor=self.word_processor,
            text_parser=self.text_parser,
            srs_system=self.srs_system,
            safe_reply_callback=self._safe_reply,
            process_text_callback=self._process_text_for_user,
            start_study_session_callback=self.session_manager.start_study_session,
            state_manager=self.state_manager,
            session_manager=self.session_manager,
        )

        self.message_handlers = MessageHandlers(
            safe_reply_callback=self._safe_reply,
            process_text_callback=self._process_text_for_user,
            handle_study_callback=self.session_manager.handle_study_callback,
            state_manager=self.state_manager,
            session_manager=self.session_manager,
        )

    def _is_user_authorized(self, user_id: int) -> bool:
        """Check if user is authorized to use the bot"""
        if not self.settings.allowed_users_list:
            return False
        return user_id in self.settings.allowed_users_list

    async def _check_authorization(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ) -> bool:
        """Check if user is authorized and send unauthorized message if not"""
        user_id = update.effective_user.id

        if not self._is_user_authorized(user_id):
            await self._safe_reply(
                update,
                "‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.",
                reply_markup=ReplyKeyboardRemove(),
            )
            logger.warning(f"Unauthorized access attempt from user {user_id}")
            return False

        return True

    def require_authorization(self, func):
        """Decorator to require authorization for handler functions"""

        @wraps(func)
        async def wrapper(update: Update, context: ContextTypes.DEFAULT_TYPE):
            if not await self._check_authorization(update, context):
                return
            return await func(update, context)

        return wrapper

    async def start(self):
        """Start the bot"""
        logger.info("Starting German Learning Bot...")

        # Initialize database
        self.db_manager.init_database()

        # Start lock manager and state manager
        await self.lock_manager.start()
        await self.state_manager.start()

        try:
            # Create application
            self.application = (
                Application.builder()
                .token(self.settings.telegram_bot_token)
                .read_timeout(30)
                .write_timeout(30)
                .connect_timeout(30)
                .pool_timeout(30)
                .post_init(self.setup_bot_menu)
                .build()
            )

            # Add handlers
            self._add_handlers()

            # Start polling
            logger.info("Bot started successfully!")
            await self.application.run_polling(
                poll_interval=self.settings.polling_interval,
                timeout=10,
                bootstrap_retries=3,
            )
        finally:
            # Stop managers on shutdown
            await self.lock_manager.stop()
            await self.state_manager.stop()

    def run(self):
        """Run the bot (synchronous entry point)"""
        logger.info("Starting German Learning Bot...")

        # Initialize database
        self.db_manager.init_database()

        # Create application
        self.application = (
            Application.builder()
            .token(self.settings.telegram_bot_token)
            .read_timeout(30)
            .write_timeout(30)
            .connect_timeout(30)
            .pool_timeout(30)
            .post_init(self.setup_bot_menu)
            .build()
        )

        # Add handlers
        self._add_handlers()

        # Start polling
        logger.info("Bot started successfully!")
        self.application.run_polling(
            poll_interval=self.settings.polling_interval,
            timeout=10,
            bootstrap_retries=3,
        )

    def _add_handlers(self):
        """Add command and message handlers"""
        app = self.application

        # Command handlers with authorization
        app.add_handler(
            CommandHandler(
                "start", self.require_authorization(self.command_handlers.start_command)
            )
        )
        app.add_handler(
            CommandHandler(
                "help", self.require_authorization(self.command_handlers.help_command)
            )
        )
        app.add_handler(
            CommandHandler(
                "add", self.require_authorization(self.command_handlers.add_command)
            )
        )
        app.add_handler(
            CommandHandler(
                "study", self.require_authorization(self.command_handlers.study_command)
            )
        )
        app.add_handler(
            CommandHandler(
                "study_new",
                self.require_authorization(self.command_handlers.study_new_command),
            )
        )
        app.add_handler(
            CommandHandler(
                "study_difficult",
                self.require_authorization(
                    self.command_handlers.study_difficult_command
                ),
            )
        )
        app.add_handler(
            CommandHandler(
                "stats", self.require_authorization(self.command_handlers.stats_command)
            )
        )
        app.add_handler(
            CommandHandler(
                "settings",
                self.require_authorization(self.command_handlers.settings_command),
            )
        )

        # Message handlers with authorization
        app.add_handler(
            MessageHandler(
                filters.TEXT & ~filters.COMMAND,
                self.require_authorization(self.message_handlers.handle_message),
            )
        )

        # Callback query handler with authorization
        app.add_handler(
            CallbackQueryHandler(
                self.require_authorization(self.message_handlers.handle_callback_query)
            )
        )

        # Error handler
        app.add_error_handler(self.error_handler)

    async def setup_bot_menu(self, application):
        """Setup bot menu with commands for better UX"""
        from telegram import BotCommand

        # Define bot commands with descriptions
        commands = [
            BotCommand("add", "üìö –î–æ–±–∞–≤–∏—Ç—å —Å–ª–æ–≤–∞ –∏–∑ —Ç–µ–∫—Å—Ç–∞"),
            BotCommand("study", "üéØ –ù–∞—á–∞—Ç—å –∏–∑—É—á–µ–Ω–∏–µ —Å–ª–æ–≤"),
            BotCommand("study_new", "üÜï –ò–∑—É—á–∞—Ç—å —Ç–æ–ª—å–∫–æ –Ω–æ–≤—ã–µ —Å–ª–æ–≤–∞"),
            BotCommand("study_difficult", "üî• –ü–æ–≤—Ç–æ—Ä–∏—Ç—å —Å–ª–æ–∂–Ω—ã–µ —Å–ª–æ–≤–∞"),
            BotCommand("stats", "üìä –ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"),
            BotCommand("help", "‚ùì –°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º"),
            BotCommand("settings", "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–æ—Ç–∞"),
        ]

        try:
            # Set commands for the bot menu
            await application.bot.set_my_commands(commands)
            logger.info("Bot menu commands set successfully")
        except Exception as e:
            logger.error(f"Failed to set bot menu commands: {e}")

    async def _process_text_for_user(self, update: Update, text: str):
        """Process German text and add words for user"""
        user = update.effective_user

        # Check if user is already processing
        if self.lock_manager.is_locked(user.id):
            lock_info = self.lock_manager.get_lock_info(user.id)
            await self._safe_reply(
                update,
                f"‚è≥ –û–±—Ä–∞–±–æ—Ç–∫–∞ —É–∂–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è!\n\n"
                f"üîí –û–ø–µ—Ä–∞—Ü–∏—è: {lock_info.operation}\n"
                f"‚è∞ –ù–∞—á–∞—Ç–∞: {lock_info.locked_at.strftime('%H:%M:%S')}\n\n"
                f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–∂–¥–∏—Ç–µ—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–π –æ–ø–µ—Ä–∞—Ü–∏–∏.",
                reply_markup=ReplyKeyboardRemove(),
            )
            return

        # Acquire lock for this user
        if not self.lock_manager.acquire_lock(user.id, "add_words"):
            await self._safe_reply(
                update,
                "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏. "
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
                reply_markup=ReplyKeyboardRemove(),
            )
            return

        try:
            # Get user from database
            db_user = self.db_manager.get_user_by_telegram_id(user.id)
            if not db_user:
                await self._safe_reply(
                    update,
                    "‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏.",
                    reply_markup=ReplyKeyboardRemove(),
                )
                return

            # Show processing message
            processing_msg = await self._safe_reply(
                update,
                "üîç –ò–∑–≤–ª–µ–∫–∞—é —Å–ª–æ–≤–∞ –∏–∑ —Ç–µ–∫—Å—Ç–∞...\n‚è≥ –ü—Ä–æ–≤–µ—Ä—è—é –Ω–æ–≤—ã–µ —Å–ª–æ–≤–∞...",
                reply_markup=ReplyKeyboardRemove(),
            )

            timer = Timer()
            timer.start()

            # Extract words
            extracted_words = self.text_parser.extract_words(text, max_length=50)

            if not extracted_words:
                await self._safe_edit_message(
                    processing_msg,
                    "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å —Å–ª–æ–≤–∞ –∏–∑ —Ç–µ–∫—Å—Ç–∞.\n\n"
                    "–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ç–µ–∫—Å—Ç —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ–º–µ—Ü–∫–∏–µ —Å–ª–æ–≤–∞."
                )
                return

            # Limit number of words
            max_words = self.settings.max_words_per_request
            if len(extracted_words) > max_words:
                extracted_words = extracted_words[:max_words]

            # Check which words already exist
            word_existence = self.db_manager.check_multiple_words_exist(
                db_user["telegram_id"], extracted_words
            )

            existing_words = [word for word, exists in word_existence.items() if exists]
            new_words = [word for word, exists in word_existence.items() if not exists]

            # Process new words
            if new_words:
                await self._safe_edit_message(
                    processing_msg,
                    f"üìù –ù–∞–π–¥–µ–Ω–æ —Å–ª–æ–≤: <b>{len(extracted_words)}</b>\n"
                    f"üÜï –ù–æ–≤—ã—Ö —Å–ª–æ–≤: <b>{len(new_words)}</b>\n"
                    f"‚Ü©Ô∏è –£–∂–µ –∏–∑—É—á–∞—é—Ç—Å—è: <b>{len(existing_words)}</b>\n\n"
                    f"ü§ñ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –Ω–æ–≤—ã–µ —Å–ª–æ–≤–∞ —Å OpenAI...\n"
                    f"‚è≥ –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥.",
                    parse_mode="HTML",
                )

                # Process with word processor
                processed_words = await self.word_processor.process_text(
                    " ".join(new_words), max_words=len(new_words)
                )

                if processed_words:
                    # Convert to dict format for database
                    words_data = []
                    for pw in processed_words:
                        words_data.append(
                            {
                                "lemma": pw.lemma,
                                "part_of_speech": pw.part_of_speech,
                                "article": pw.article,
                                "translation": pw.translation,
                                "example": pw.example,
                                "additional_forms": pw.additional_forms,
                                "confidence": pw.confidence,
                            }
                        )

                    # Add to database
                    added_count = self.db_manager.add_words_to_user(
                        db_user["telegram_id"], words_data
                    )

                    # Log detailed results
                    processed_count = len(processed_words)
                    if added_count != processed_count:
                        skipped_count = processed_count - added_count
                        logger.warning(
                            f"Word addition mismatch: processed {processed_count} "
                            f"words, "
                            f"but only {added_count} were added to database. "
                            f"{skipped_count} words were skipped."
                        )
                        for pw in processed_words:
                            logger.info(
                                f"Processed word details: '{pw.lemma}' "
                                f"({pw.part_of_speech}) - '{pw.translation}'"
                            )

                    timer.stop()

                    # Get details for existing words if any
                    existing_words_details = []
                    if existing_words:
                        existing_words_details = (
                            self.db_manager.get_existing_words_details(
                                db_user["telegram_id"], existing_words
                            )
                        )

                    # Build success message
                    success_msg = f"""‚úÖ <b>–û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>

üìä <b>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã:</b>
‚Ä¢ –í—Å–µ–≥–æ —Å–ª–æ–≤ –Ω–∞–π–¥–µ–Ω–æ: <b>{len(extracted_words)}</b>
‚Ä¢ –ù–æ–≤—ã—Ö –¥–æ–±–∞–≤–ª–µ–Ω–æ: <b>{added_count}</b>
‚Ä¢ –£–∂–µ –∏–∑—É—á–∞—é—Ç—Å—è: <b>{len(existing_words)}</b>

‚è±Ô∏è <b>–í—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∫–∏:</b> {timer.get_elapsed_time():.1f}—Å"""

                    # Add existing words list if any
                    if existing_words_details:
                        success_msg += "\n\nüìö <b>–£–∂–µ –∏–∑—É—á–∞–µ–º—ã–µ —Å–ª–æ–≤–∞:</b>\n"
                        for word in existing_words_details:
                            article_part = (
                                f"{word['article']} " if word["article"] else ""
                            )
                            success_msg += f"‚Ä¢ {article_part}<i>{word['lemma']}</i> ‚Äî {word['translation']}\n"

                    success_msg += "\nüéØ –ù–∞—á–Ω–∏—Ç–µ –∏–∑—É—á–µ–Ω–∏–µ —Å –∫–æ–º–∞–Ω–¥—ã /study"

                    await self._safe_edit_message(processing_msg, success_msg, parse_mode="HTML")
                else:
                    await self._safe_edit_message(
                        processing_msg,
                        "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Å–ª–æ–≤–∞ —Å –ø–æ–º–æ—â—å—é OpenAI.\n"
                        "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
                    )
            else:
                # Get details for all existing words
                existing_words_details = self.db_manager.get_existing_words_details(
                    db_user["telegram_id"], existing_words
                )

                # Build message showing all existing words
                msg = f"üìö –ù–∞–π–¥–µ–Ω–æ —Å–ª–æ–≤: <b>{len(extracted_words)}</b>\n"
                msg += "‚Ü©Ô∏è –í—Å–µ —Å–ª–æ–≤–∞ —É–∂–µ –∏–∑—É—á–∞—é—Ç—Å—è!\n\n"

                if existing_words_details:
                    msg += "üìö <b>–ò–∑—É—á–∞–µ–º—ã–µ —Å–ª–æ–≤–∞:</b>\n"
                    for word in existing_words_details:
                        article_part = f"{word['article']} " if word["article"] else ""
                        msg += f"‚Ä¢ {article_part}<i>{word['lemma']}</i> ‚Äî {word['translation']}\n"
                    msg += "\n"

                msg += "üéØ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /study –¥–ª—è –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è —Å–ª–æ–≤."

                await self._safe_edit_message(processing_msg, msg, parse_mode="HTML")

        except Exception as e:
            logger.error(f"Error processing text: {e}")
            with contextlib.suppress(Exception):
                await self._safe_edit_message(
                    processing_msg,
                    "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ç–µ–∫—Å—Ç–∞.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
                )
        finally:
            # Always release the lock
            self.lock_manager.release_lock(user.id)

    async def _safe_reply(self, update_or_query, text: str, **kwargs):
        """Safely send a reply message"""
        try:
            if hasattr(update_or_query, "message"):
                # It's an Update object
                return await update_or_query.message.reply_text(text, **kwargs)
            else:
                # It's a Message object
                return await update_or_query.reply_text(text, **kwargs)
        except TelegramError as e:
            logger.error(f"Error sending reply: {e}")
            return None

    async def _safe_edit(self, query, text: str, **kwargs):
        """Safely edit a message"""
        try:
            return await query.edit_message_text(text, **kwargs)
        except TelegramError as e:
            logger.error(f"Error editing message: {e}")
            return None

    async def _safe_edit_message(self, message, text: str, **kwargs):
        """Safely edit a message with fallback to new message"""
        try:
            return await message.edit_text(text, **kwargs)
        except TelegramError as e:
            logger.error(f"Error editing message: {e}")
            # If editing fails, send a new message instead
            try:
                return await message.reply_text(text, **kwargs)
            except TelegramError as e2:
                logger.error(f"Error sending fallback message: {e2}")
                return None

    async def error_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle errors"""
        logger.error(f"Update {update} caused error {context.error}")


# For backward compatibility
def get_bot_handler(settings=None) -> BotHandler:
    """Get bot handler instance"""
    return BotHandler(settings)
